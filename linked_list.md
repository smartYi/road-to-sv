+ **两种存储方式**
    + 顺序存储结构：随机读取，访问时是 O(1)
    + 链式存储结构：插入和删除 O(1)，访问时最坏是 O(n)
+ 分类（根据指针域）
    + 单向链表
    + 双向链表
    + 循环链表

## 反转链表

+ 访问某个节点 `curt.next` 时，要检验 `curt` 是否为 `null`
+ 要把反转后的最后一个节点（即第一个节点）指向 `null`

## 删除某个节点

+ 由于需要知道前继节点的信息，而前继节点可能会导致表头产生变化，所以需要一些技巧 `Dummy Node`
+ 链表指针的鲁棒性
    + 访问某个节点 `curt.next` 时，要检验 `curt` 是否为 `null`
    + 全部操作结束后，判断是否有环；若有，则置其中一端为 `null`

## Dummy Node

+ 是一个虚拟节点 `dummy.next = head`
+ 针对单向链表没有前向指针的问题，保证链表的 `head` 不会在删除操作中丢失
+ 也可以用来进行 `head` 节点（但比较少见）
+ 当链表的 `head` 可能有变化时，使用 dummy node 可以简化代码，最后返回 `dummy.next` 即可

## 快慢指针

+ 快慢指的是指针向前移动的步长，一般来说，快指针每次移动 2，慢指针每次移动 1
+ 主要有两个应用
    + **快速找出未知长度单链表的中间节点**
        + 设置两个指针 `*fast` 和 `*slow` 都指向头节点
        + `*fast` 移动速度是 `*slow` 的两倍
        + `*fast` 指向末尾节点时，`*slow` 正好就在中间
    + **判断单链表是否有环**
        + 设置两个指针 `*fast` 和 `*slow` 都指向头节点
        + `*fast` 移动速度是 `*slow` 的两倍
        + 如果 `*fast == null` 说明该单链表不是循环链表
        + 如果 `*fast == *slow` 说明该链表是循环链表
+ 其他应用
    + **找倒数第 N 个节点**
        + 设置两个指针 `*fast` 和 `*slow` 都指向头节点
        + `*fast` 先移动 N 步，然后两个指针一起前进
        + `*fast` 到达末尾时，`*slow` 即为倒数第 N 个节点