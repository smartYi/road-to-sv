# 完美洗牌算法

有个长度为`2n`的数组`{a1,a2,a3,...,an,b1,b2,b3,...,bn}`，希望排序后`{a1,b1,a2,b2,....,an,bn}`，请考虑有无时间复杂度`o(n)`，空间复杂度`0(1)`的解法。

题目来源 ：此题是去年2013年UC的校招笔试题，看似简单，按照题目所要排序后的字符串蛮力变化即可，但若要完美的达到题目所要求的时空复杂度，则需要我们花费不小的精力。OK，请看下文详解，一步步优化。

## 分析与解法

### 解法一 蛮力变换

题目要我们怎么变换，咱们就怎么变换。为了便于分析，我们取`n=4`，那么题目要求我们把

    a1，a2，a3，a4， b1，b2，b3，b4

变成

    a1，b1，a2，b2，a3，b3，a4，b4

#### 1.1 步步前移

仔细观察变换前后两个序列的特点，我们可做如下一系列操作：

第1步、确定`b1`的位置，即让`b1`跟它前面的`a2`，`a3`，`a4`交换：

    a1，b1，a2，a3，a4， b2，b3，b4

第2步、接着确定`b2`的位置，即让`b2`跟它前面的`a3`，`a4`交换：

    a1，b1，a2，b2，a3，a4， b3，b4

第3步、`b3`跟它前面的`a4`交换位置：

    a1，b1，a2，b2，a3，b3，a4，b4

`b4`已在最后的位置，不需要再交换。如此，经过上述`3`个步骤后，得到我们最后想要的序列。但此方法的时间复杂度为`O(N^2)`，我们得继续寻找其它方法，看看有无办法能达到题目所预期的O（N）的时间复杂度。

#### 1.2 中间交换

当然，除了如上面所述的让`b1，b2，b3，b4`步步前移跟它们各自前面的元素进行交换外，我们还可以每次让序列中最中间的元素进行交换达到目的。还是用上面的例子，针`对a1，a2，a3，a4，b1，b2，b3，b4`

第1步：交换最中间的两个元素`a4`，`b1`，序列变成：

    a1，a2，a3，b1，a4，b2，b3，b4

第2步，让最中间的两对元素各自交换：

    a1，a2，b1，a3，b2，a4，b3，b4

第3步，交换最中间的三对元素，序列变成：

    a1，b1，a2，b2，a3，b3，a4，b4

同样，此法同解法`1.1 步步前移`一样，时间复杂度依然为`O(N^2)`，我们得下点力气了。

### 解法二 完美洗牌算法

玩过扑克牌的朋友都知道，在一局完了之后洗牌，洗牌人会习惯性的把整副牌大致分为两半，两手各拿一半对着对着交叉洗牌

如果这副牌用`a1 a2 a3 a4 b1 b2 b3 b4`表示（为简化问题，假设这副牌只有8张牌），然后一分为二之后，左手上的牌可能是`a1 a2 a3 a4`，右手上的牌是`b1 b2 b3 b4`，那么在如上图那样的洗牌之后，得到的牌就可能是`b1 a1 b2 a2 b3 a3 b4 a4`。

技术来源于生活，2004年，`microsoft`的`Peiyush Jain`在他发表一篇名为：`A Simple In-Place Algorithm for In-Shuffle`的论文中提出了完美洗牌算法。

这个算法解决一个什么问题呢？跟本题有什么联系呢？

Yeah，顾名思义，完美洗牌算法解决的就是一个完美洗牌问题。什么是完美洗牌问题呢？即给定一个数组`a1,a2,a3,...an,b1,b2,b3..bn`,最终把它置换成`b1,a1,b2,a2,...bn,an`。读者可以看到，这个完美洗牌问题本质上与本题完全一致，只要在完美洗牌问题的基础上对它最后的序列`swap`两两相邻元素即可。

即：

    a1,a2,a3,...an,b1,b2,b3..bn
  
通过完美洗牌问题，得到：

    b1,a1,b2,a2,b3,a3...  bn,an

再让上面相邻的元素两两`swap`，即可达到本题的要求：

    a1,b1,a2,b2,a3,b3....,an,bn

也就是说，如果我们能通过完美洗牌算法（时间复杂度`O(N)`，空间复杂度`O(1)`）解决了完美洗牌问题，也就间接解决了本题。

虽然网上已有不少文章对上篇论文或翻译或做解释说明，但对于初学者来说，理解难度实在太大，再者，若直接翻译原文，根本无法看出这个算法怎么一步步得来的，故下文将从完美洗牌算法的最基本的原型开始说起，以让读者能对此算法一目了然。

#### 2.1 位置置换`pefect_shuffle1`算法

为方便讨论，我们设定数组的下标从`1`开始，下标范围是`[1..2n]`。 还是通过之前`n=4`的例子，来看下每个元素最终去了什么地方。

起始序列：`a1 a2 a3 a4 b1 b2 b3 b4` 数组下标：`1 2 3 4 5 6 7 8` 最终序列：`b1 a1 b2 a2 b3 a3 b4 a4`

从上面的例子我们能看到，前n个元素中，

+ 第`1`个元素`a1`到了原第`2`个元素`a2`的位置，即`1->2`；
+ 第`2`个元素`a2`到了原第`4`个元素`a4`的位置，即`2->4`；
+ 第`3`个元素`a3`到了原第`6`个元素`b2`的位置，即`3->6`；
+ 第`4`个元素`a4`到了原第`8`个元素`b4`的位置，即`4->8`；

那么推广到一般情况即是：前`n`个元素中，第`i`个元素去了 第`2*i`的位置。

上面是针对前`n`个元素，那么针对后`n`个元素，可以看出：

+ 第`5`个元素`b1`到了原第`1`个元素`a1`的位置，即`5->1`；
+ 第`6`个元素`b2`到了原第`3`个元素`a3`的位置，即`6->3`；
+ 第`7`个元素`b3`到了原第`5`个元素`b1`的位置，即`7->5`；
+ 第`8`个元素`b4`到了原第`7`个元素`b3`的位置，即`8->7`；

推广到一般情况是，后`n`个元素，第`i`个元素去了第 `(2*(i-n))-1 = 2*i - (2*n+1) = (2*i) % (2*n + 1)` 个位置。

再综合到任意情况，任意的第`i`个元素，我们最终换到了`(2*i) % (2*n+1)`的位置。为何呢？因为：

+ 当`0 < i < n`时， `原式= (2*i) % (2*n+1) = 2i`；
+ 当`i > n`时，`原式=(2*i) % (2*n+1)`保持不变。

因此，如果题目允许我们再用一个数组的话，我们直接把每个元素放到该放得位置就好了。也就产生了最简单的方法`pefect_shuffle1`，参考代码如下：

```cpp
// 时间O(n)，空间O(n) 数组下标从1开始
void PefectShuffle1(int *a, int n)
{
    int n2 = n * 2, i, b[N];
    for (i = 1; i <= n2; ++i)
    {
        b[(i * 2) % (n2 + 1)] = a[i];
    }
    for (i = 1; i <= n2; ++i)
    {
        a[i] = b[i];
    }
}
```

但很明显，它的时间复杂度虽然是`O(n)`，但其空间复杂度却是`O(n)`，仍不符合本题所期待的时间`O(n)`，空间`O(1)`。我们继续寻找更优的解法。

与此同时，我也提醒下读者，根据上面变换的节奏，我们可以看出有两个圈，

+ 一个是`1 -> 2 -> 4 -> 8 -> 7 -> 5 -> 1`；
+ 一个是`3 -> 6 -> 3`。

下文`2.2.1 走圈算法cycle_leader`将再次提到这两个圈。

#### 2.2、完美洗牌算法`perfect_shuffle2`

**2.2.1 走圈算法`cycle_leader`**

因为之前`perfect_shuffle1`算法未达到时间复杂度`O(N)`并且空间复杂度`O(1)`的要求，所以我们必须得再找一种新的方法，以期能完美的解决本节开头提出的完美洗牌问题。

让我们先来回顾一下`2.1 位置置换perfect_shuffle1`算法，还记得我之前提醒读者的关于当n=4时，通过位置置换让每一个元素到了最后的位置时，所形成的两个圈么？我引用下2.1节的相关内容：

`n=4`的情况：

起始序列：`a1 a2 a3 a4 b1 b2 b3 b4` 数组下标：`1 2 3 4 5 6 7 8` 最终序列：`b1 a1 b2 a2 b3 a3 b4 a4`

即通过置换，我们得到如下结论：

“于此同时，我也提醒下读者，根据上面变换的节奏，我们可以看出有两个圈，

+ 一个是`1 -> 2 -> 4 -> 8 -> 7 -> 5 -> 1`；
+ 一个是`3 -> 6 -> 3`。

这两个圈可以表示为`(1,2,4,8,7,5)`和`(3,6)`，且`perfect_shuffle1`算法也已经告诉了我们，不管你`n`是奇数还是偶数，每个位置的元素都将变为第`(2*i) % (2n+1)`个元素：

因此我们只要知道圈里最小位置编号的元素即圈的头部，顺着圈走一遍就可以达到目的，且因为圈与圈是不相交的，所以这样下来，我们刚好走了`O(N)`步。

还是举`n=4`的例子，且假定我们已经知道第一个圈和第二个圈的前提下，要让`1 2 3 4 5 6 7 8`变换成`5 1 6 2 7 3 8 4`：

+ 第一个圈：`1 -> 2 -> 4 -> 8 -> 7 -> 5 -> 1` 第二个圈：`3 -> 6 -> 3`：
+ 原始数组：`1 2 3 4 5 6 7 8` 数组下标：`1 2 3 4 5 6 7 8`
+ 走第一圈：`5 1 3 2 7 6 8 4` 走第二圈：`5 1 6 2 7 3 8 4`

上面沿着圈走的算法我们给它取名为`cycle_leader`，这部分代码如下：

```cpp
//数组下标从1开始，from是圈的头部，mod是要取模的数 mod 应该为 2 * n + 1，时间复杂度O(圈长）
void CycleLeader(int *a, int from, int mod)
{
    int t,i;

    for (i = from * 2 % mod; i != from; i = i * 2 % mod)
    {
        t = a[i];
        a[i] = a[from];
        a[from] = t;
    }
}
```

**2.2.2 神级结论：若`2*n=(3^k - 1)`，则可确定圈的个数及各自头部的起始位置**

下面我要引用此论文“A Simple In-Place Algorithm for In-Shuffle”的一个结论了，即 对于`2*n = (3^k-1)`这种长度的数组，恰好只有`k`个圈，且每个圈头部的起始位置分别是`1,3,9，...3^(k-1)`。

论文原文部分为：

![](14.jpg)

也就是说，利用上述这个结论，我们可以解决这种特殊长度`2*n = （3^k-1）`的数组问题，那么若给定的长度n是任意的咋办呢？此时，我们可以采取分而治之算法的思想，把整个数组一分为二，即拆分成两个部分：

+ 让一部分的长度满足神级结论：若`2*m = (3^k-1)`，则恰好`k`个圈，且每个圈头部的起始位置分别`是1,3,9，...3^(k-1)`。其中`m < n`，`m`往神级结论所需的值上套；
+ 剩下的`n-m`部分单独计算；

当把`n`分解成`m`和`n-m`两部分后，原始数组对应的下标如下（为了方便描述，我们依然只需要看数组下标就够了）：

原始数组下标：`1..m m+1.. n， n+1 .. n+m, n+m+1,..2*n`

且为了能让前部分的序列满足神级结论`2*m = (3^k-1)`，我们可以把中间那两段长度为`n-m`和`m`的段交换位置，即相当于把`m+1..n，n+1..n+m`的段循环右移`m`次（为什么要这么做？因为如此操作后，数组的前部分的长度为`2m`，而根据神级结论：当`2m=3^k-1`时，可知这长度`2m`的部分恰好有`k`个圈）。

而如果读者看过本系列第一章、左旋转字符串的话，就应该意识到循环位移是有`O(N)`的算法的，其思想即是把前`n-m`个元素`(m+1.. n)`和后`m`个元素`(n+1 .. n+m)`先各自翻转一下，再将整个段`(m+1.. n， n+1 .. n+m)`翻转下。

这个翻转的代码如下：

```cpp
//翻转字符串时间复杂度O(to - from)
void reverse(int *a, int from, int to)
{
    int t;
    for (; from < to; ++from, --to)
    {
        t = a[from];
        a[from] = a[to];
        a[to] = t;
    }
}

//循环右移num位 时间复杂度O(n)
void RightRotate(int *a, int num, int n)
{
    reverse(a, 1, n - num);
    reverse(a, n - num + 1, n);
    reverse(a, 1, n);
}
```

翻转后，得到的目标数组的下标为：

    目标数组下标：1..m n+1..n+m    m+1 .. n       n+m+1,..2*n

OK，理论讲清楚了，再举个例子便会更加一目了然。当给定`n=7`时，若要满足神级结论`2*n=3^k-1`，k只能取`2`，继而推得`n'=m=4`。

    原始数组：a1 a2 a3 a4       a5 a6 a7     b1 b2 b3 b4   b5 b6 b7

既然`m=4`，即让上述数组中有下划线的两个部分交换，得到：

    目标数组：a1 a2 a3 a4    b1 b2 b3 b4      a5 a6 a7     b5 b6 b7

继而目标数组中的前半部分`a1 a2 a3 a4 b1 b2 b3 b4`部分可以用`2.2.1 走圈算法cycle_leader`搞定，于此我们最终求解的`n`长度变成了`n'=3`，即`n`的长度减小了`4`，单独再解决后半部分`a5 a6 a7 b5 b6 b7`即可。

**2.2.3 完美洗牌算法`perfect_shuffle3`**

从上文的分析过程中也就得出了我们的完美洗牌算法，其算法流程为：

+ 输入数组　`A[1..2 * n]`
+ step 1 找到 `2*m = 3^k - 1` 使得 `3^k <= 2*n < 3^(k+1)`
+ step 2 把`a[m+1..n+m]`那部分循环移`m`位
+ step 3 对每个`i = 0,1,2..k - 1`，`3^i`是个圈的头部，做`cycle_leader`算法，数组长度为`m`，所以对`2 * m + 1`取模。
+ step 4 对数组的后面部分`A[2*m+1.. 2*n]`继续使用本算法, 这相当于`n`减小了`m`。

以上各个步骤对应的时间复杂度分析如下：

+ 因为循环不断乘3的，所以时间复杂度`O(logn)`
+ 循环移位`O(n)`
+ 每个圈，每个元素只走了一次，一共`2*m`个元素，所以复杂度`O(m)`, 而`m < n`，所以 也在`O(n)`内。 `T(n - m)`

因此总的时间复杂度为 `T(n) = T(n - m) + O(n) ，m = O(n)` ，解得：`T(n) = O(n)`。

此完美洗牌算法实现的参考代码如下：

```cpp
//copyright@caopengcs 8/24/2013
//时间O(n)，空间O(1)
void PerfectShuffle2(int *a, int n)
{
    int n2, m, i, k, t;
    for (; n > 1;)
    {
        // step 1
        n2 = n * 2;
        for (k = 0, m = 1; n2 / m >= 3; ++k, m *= 3)
          ;
        m /= 2;
        // 2m = 3^k - 1 , 3^k <= 2n < 3^(k + 1)

        // step 2
        right_rotate(a + m, m, n);

        // step 3
        for (i = 0, t = 1; i < k; ++i, t *= 3)
        {
          cycle_leader(a , t, m * 2 + 1);
        }

        //step 4
        a += m * 2;
        n -= m;

    }
    // n = 1
    t = a[1];
    a[1] = a[2];
    a[2] = t;
}
```

**2.2.4 `perfect_shuffle2`算法解决其变形问题**

啊哈！以上代码即解决了完美洗牌问题，那么针对本章要解决的其变形问题呢？是的，如本章开头所说，在完美洗牌问题的基础上对它最后的序列swap两两相邻元素即可，代码如下：

```cpp
//copyright@caopengcs 8/24/2013
//时间复杂度O(n)，空间复杂度O(1)，数组下标从1开始，调用perfect_shuffle3
void shuffle(int *a, int n)
{
    int i, t, n2 = n * 2;
    PerfectShuffle2(a, n);
    for (i = 2; i <= n2; i += 2)
    {
        t = a[i - 1];
        a[i - 1] = a[i];
        a[i] = t;
   }
}
```

上述的这个“在完美洗牌问题的基础上对它最后的序列`swap`两两相邻元素”的操作（当然，你也可以让原数组第一个和最后一个不变，中间的`2*(n-1)`项用原始的标准完美洗牌算法做），只是在完美洗牌问题时间复杂度`O(N)`空间复杂度`O(1)`的基础上再增加`O(N)`的时间复杂度，故总的时间复杂度`O(N)`不变，且理所当然的保持了空间复杂度`O(1)`。至此，咱们的问题得到了圆满解决！

## 举一反三

至此，本章开头提出的问题解决了，是否可以止步了呢？OH，NO！读者有无思考过下述问题：

1. 既然完美洗牌问题是给定输入：`a1,a2,a3,……aN,b1,b2,b3,……bN`，要求输出：`b1,a1,b2,a2,……bN,aN`；那么有无考虑过它的逆问题：即给定`b1,a1,b2,a2,……bN,aN`,，要求输出`a1,a2,a3,……aN,b1,b2,b3,……bN` ？
2. 完美洗牌问题是两手洗牌，假设有三只手同时洗牌呢？那么问题将变成：输入是`a1,a2,……aN, b1,b2,……bN, c1,c2,……cN`，要求输出是`c1,b1,a1,c2,b2,a2,……cN,bN,aN`，这个时候，怎么处理？