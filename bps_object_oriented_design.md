# Object Oriented Design

对于初级程序员的面试，最难的部分可能就是所谓的设计题。设计题可以分成两个类别：系统架构设计和利用面向对象编程原理进行程序设计。前者所涉及的技术往往包括数据库，并发处理和分布式系统等等，对于经验要求和知识要求比较高。我们先来看看系统设计的面试流程:

1. 题目描述
    + 往往非常简单，如：设计一个XX系统。或者：你有没有用过XXX，给你看一下它的界面和功能，你来设计一个。
2. 阐述题意
    + 面试者需向面试官询问系统的具体要求。如，需要什么功能，需要承受的流量大小，是否需要考虑可靠性，容错性等等。
3. 面试者提供一个初步的系统设计
4. 面试官这对初步的系统中提出一些后续的问题：如果要加某个功能怎么办，如果流量大了怎么办，如何考虑一致性，如果机器挂了怎么办。
5. 面试者根据面试官的后续问题逐步完善系统设计
6. 完成面试

总体特点是以交流为主，画图和代码为辅。

根据我们面试别人和参与面试的经验，先从面试官的角度给出一些考量标准：

+ 适应变化的需求(Adapt to the changing requirements )
+ 设计干净，优美，考虑周到的系统(Produce a system that is clean, elegant, well thought )
+ 解释为何这么实现(Explain why you choose this implementation )
+ 对自己的能力水平很熟练(Be familiar with your experience level to make decisions )
+ 在一些高层结构和复杂性方面有设计(Answer in high level of scale and complexity )

按照评分体系的化，分成下面4个等级

| Scoring | Candidate | Criteria |
| :--: | :--: | :--: |
| 1.0 | Bad | No sense of requirement, no scoping |
| 2.0 | Poor | Limited knowledge, common sense |
| 3.0 | Good | Reasonable Solution, explain clearly |
| 4.0 | Great | Out of expectation, well thoughtful, trade-off |

其实大家大可不必追求完美，在真正的面试中，没有人能对答如流，往往面试官也会给出善意的提示，就算你没回答某个子问题，在面试后的评价中也会综合衡量，跟其他的面试者比较，最终打出一个分数。我认为很多人在2到3分左右，当然我们目标是尽量在3分以上。

### 模拟面试

下面我就来做个模拟面试(Mock Interview)，那一到很经典的TinyURL举例：
TinyURL是说给你一个长URL，通过某一种编码，你把它压缩成5个字母(数字)长度的code，然后当给出短链接，要能还原出来原来的URL。举个例子：

+ 原始URL：http://www.zhihu.com/abc?user=12345
+ TinyURL: http://t.cn/xcef0
+ 当访问 TinyURL，会自动跳转到原始URL。

**等级1**

最直接想到的是用一个数据库，把原始URL存入数据库中，ID就是自增主键，避免重复。当访问TinyURL时候就去数据库查询，当查询成功就返回原始URL，没有就返回空。这是不是很简单？

想到这还是太容易了，虽然这是个正确的方法，但没考量全面。比如这里面编码是用数字，没有很好利用5个字节的表示空间，然后在性能方面，每次都是查询数据库这样效率不高。那么我们看下面的方法

**等级1.5**

上面使用数字能表达的URL最多就是0－99999, 10万条，那么使用Base 64编码，所谓base 64是有64个不同字符构成，比如a到z，A到Z，0到9，再加上2个特殊符号，比如_, -，这样能表示的就是64^5 = 2^30 是大约10亿的大小。这样就极大提高了空间容量。

然后为了提高性能，可以加上缓存，缓存大小是有限的，我们如何让一些不常用的查询从缓存中替换出去，这里面就涉及到缓存淘汰算法，常用的LRU(Least Recent Use)和LFU(Least Frequent Use)，一个是最近最少访问，一个是最不频繁访问，我们在这里使用LFU就比较合适。

到了这里，设计还是不够好，一个是性能还是可能出现瓶颈，当我们在使用单个数据库，如果查询依然很多，到每秒1万次以上怎么办？使用的是那种数据库，如果数据库当机怎么办？

**等级2.0**

使用key-value存储的数据库，所谓的Key-value pair就是NoSQL的一种经典应用，传统数据库为了支持事务，外键，有很多需要考虑。但key-value型数据库，就减少了这么多限制，对这种典型通过某个key查询value的，就直接用这个合适，它的吞吐量可以比传统MySQL 有10倍以上的提升。另外一个是关于如何快速生成短code，有一个md5的算法，它是用在单项加密上，最直接的把一段信息加密成128bit大小，如果我们算一下，128bits 是16个bytes，这样就超过了题目要求的5个，那么我们可以做一个尾部截取，但这样又会带来hash重合的问题，大家可以想想有没有更好的解决方法。

**等级3.0**

下面可以再考虑分布式，可靠性的问题。刚才说了一台机器可能导致挂了就失去服务和数据。那我们可以用多台机器，通过sharding的方式，就是把某个URL取一个hash值再％N，这样就把这个请求分配到某台具体机器上，然后再这台机器上进行读取或者存储。另外我们要注意一种分配不均的情况，你可以想象也许机器1就是非常热门，它的负载比其他的机器高很多，但总体负载又不高，如果我们简单的扩容，一方面浪费了机器，涉及到迁移成本，并且也不见得解决真正1号机负载高的问题。最好的做法是把1号机的旁边再放置一台同样规模和数据的机器，这个叫热等待(Hot standby), 通过流量的导流，实现负载均衡。对于可靠性，你想象某台机器当机，它如何做恢复呢？首先你要保证数据是有备份的，也许再另一个数据库中，然后当那台机器重启后，可以先载入上次备份的地方，也叫快照(snapshot)，然后再把日志中应该重新做的操作继续做一遍，这样就保证了数据的一致性。

**等级4.0**

其实到这一步，更多的是一些后续问题，比如你怎么解决生成全局唯一的token号，这里面可以用zookeeper作为工具，在集群中协作保证生成唯一ID，具体算法可以参考Paxos。此外，还可能会问如何防止TinyURL被爬取，刚才我们看到的例子如果是按正常顺序，就是1，2，3……9，a，b，这样很容易被机器抓取，有个简单办法，内部你做一个乱序对应表，比如z对应1, w对应2，b对应34，这样就比较难猜到你的生成规则。还可能接着问如何限制用户访问，当某个用户每分钟到达一定次数就禁止访问，可以使用一些计数器针对用户cookie做统计，当一分钟内到达阈值就触发屏蔽。还可能问如何实现URL的跳转服务，当你没有经验，可能就说自己根据HTTP协议做一个Web Server，但其实不必自己造轮子，现在apache\nginx等主流服务器早就自带重定向模块，你只需要打开这个模块配置一下就可。

---

上面说的详细解答就是想给大家一个直观认识，遇到这种面试题在不同的层次是答道什么深度，其实这些都是可以训练出来，大家不必太担心灵活性。在面试过程中，面试官一般不会对初级程序员提出这方面的问题。因此，面向对象编程原理(OOP)是设计题中需要重点准备的。下面就对一些OOP方面的设计题，多一些更为基本的补充解释。

### Abstractions, Object and Decoupling

通常，关于OOP，面试官会让面试者设计一个程序框架，该程序能够实现一些特定的功能。比如，如何实现一个音乐播放器，如何设计一个车库管理程序等等。对于此类问题，设计的关键过程一般包括抽象(abstraction)，设计对象(object)和设计合理的层次／接口(decoupling)。这里，我们举一个例子简单说明这些过程分别需要做些什么，在“模式识别”给出更为具体和完整的实例。

例：设计一个音乐播放器，能够管理专辑，播放歌曲。

抽象

“抽象的意思是能够根据设计要求，得出程序运行的逻辑框架以及定义需要的功能。简单来说，就是构想自己是该程序的使用者， 列举实现程序某个功能需要哪些步骤。比如对于我们所说的例子，播放一首歌的运行流程可能包括：添加歌曲到音乐库，添加歌曲到播放列表，播放，删除等。对于某些系统，系统可以处于多个不同状态，每个状态的功能不同，这就需要构造有限状态机。关于有限状态机的一些参考资料请见“工具箱”。在抽象的过程中，往往需要和面试官进行沟通，确认需要实现什么功能。在抽象结束后，所得到的实体就应该成为一个个对象，而功能就是对象的函数接口。比如，在本例中，涉及的实体有播放器，专辑，歌曲，播放列表。函数包括添加歌曲，删除歌曲，播放，停止，暂停等等。之后，我们就要根据“抽象的结果，进行对象设计，并且把所需的功能以函数接口的形式分配给不同的对象。

设计对象

通常而言，对于抽象出的每个实体，我们都应该构造一个类去描述它。对象之间的关系可能是继承，或者包含，具体分析请见“2. 继承/组合/参数化类型”。对于这里所需要实现的音乐播放器，我们就可以构造播放器，专辑，歌曲，播放列表这几个类。

设计接口

接口用于与用户进行交互，以及对象之间的交互。设计接口的核心在于明确每个对象需要实现什么功能，当上层对象调用下层对象的接口时，只需要提供相应的参数，就能够期待获得对应的结果。这样，上层对象不需要知道对方如何获得结果，下层对象也不需要知道对方拿到结果会进行什么样的操作。如此，通过设计恰当的接口我们就实现了decoupling：让程序具有逻辑上的层次，每一层的对象实现特定的功能，对象可以独立地更改实现功能的方法，而不会影响上层和下层。在设计接口的时候我们可能需要添加一些不那么明显的辅助类，使得程序更具有层次。比如说，考虑添加歌曲这个功能，用户会通过调用播放器的添加歌曲接口，传入一首歌。考虑到当音乐库变得很复杂的时候，我们需要判断诸如该歌曲是否已经存在，应当用怎样的数据库存储数据等等一系列问题。如果都由播放器对象来处理这些问题，会使得播放器这一层变得过为臃肿，减少代码的可读性和可维护性。所以我们可以引入另一个类，歌曲管理器，用来处理数据相关的操作。这样，用户通过播放器接口添加歌曲，播放器调用歌曲管理器的添加接口将新歌写到数据库，歌曲管理器负责打开数据库，判断数据库中是否存在重复的歌曲，写入数据等等。当之后出于某些原因需要更换储存方式的时候，只要更改歌曲管理器的代码即可。同时，如果发现播放器中有重复的歌曲，也只需要查看歌曲管理器的实现过程有什么漏洞，而不是漫无目的的找bug，这样也提升了程序的可维护性。

同时，在确定接口功能的时候，尽量把功能的具体实现向下层“推” 。比如，播放一首歌曲可以包括打开文件，访问文件等。当用户调用播放器接口要求播放一首歌时，我们可以让播放器打开文件，也可以让播放器调用歌曲对象的播放接口，由歌曲对象负责打开文件等操作。这样做的好处在于，用户可能在任何时候播放一首新的歌曲，播放器只需要有一个指针指向当前播放的歌曲对象，如果用户需要播放新的歌曲，播放器只需要：调用当前歌曲的停止接口，设置新的当前播放，调用新歌曲的播放接口即可，而不需要在播放器层反复地进行文件操作。这样，播放器层负责切换歌曲的逻辑，而歌曲层负责具体的播放操作，两者相互独立。这样的好处在于，当以后用户需要更复杂的切歌方式，只需改变播放器的实现即可；当存在更好的音乐编解码，只需要改变歌曲的播放操作即可。我们成功地decouple了切换和播放。

通常，接口的函数定义可以遵从如下模式：函数参数包括输入参数和输出参数，返回值为错误代码，或者是标示操作是否成功的布尔变量。函数需要对参数的有效性进行验证。输出参数通常传入地址，函数内可以将结果直接写到地址中。比如说，创建一个播放列表可以如下定义：

    ErrorResult createPlaylist(Vector<Song *> inSongsArray, Playlist *outPlaylist)

当ErrorResult为0时表示创建成功，outPlaylist指向该播放列表。

经过上述例子，我们作出如下总结：

+ 可以依照抽象，设计对象，设计接口的流程进行思考
+ 针对接口而不是实现来进行编程：不同对象之间保持接口
+ 一致，调用接口时不需要基于接口内的实现方式。

在之后的部分我们会给出一些常见的设计模式。但是，不要拘泥于具体的模式实现方式，我们更应该注重每种模式的意图是什么。

### 继承/组合/参数化类型

在面向对象中最常用的两种代码复用技术就是继承和组合。在设计对象的时候，“Is-A”表示一种继承关系。比如，班长“Is-A”学生，那么，学生就是基类，班长就是派生类。在确定了派生关系之后，我们需要分析什么是基类变量(base class variables)什么是子类变量(sub class variables)，并由此确定基类和派生类之间的联系。而“Has-A”表示一种从属关系，这就是组合。比如，班长“Has-A”眼镜，那就可以解释为班长实例中拥有一个眼镜实例变量(instance variable)。在具体实现的时候，班长类中定义一个眼镜的基类指针。“在生成班长实例的时候，同时生成一个眼镜实例，利用眼镜的基类指针指向这个实例。任何关于眼镜的操作函数都可以利用这个基类指针实现多态(polymorphism)。注意，多态是OOP相关的一个重要概念，也是面试常考的概念之一。关于多态的解释请见“工具箱”。

在通常情况下，我们更偏向于“Has-A”的设计模式。因为该模式减少了两个实例之间的相关性。对于继承的使用，通常情况下我们会定义一个虚基类，由此派生出多个不同的实例类。在业界的程序开发中，多重继承并不常见，Java甚至不允许从多个父类同时继承，产生一个子类。

此外，我们还要提及参数化类型。参数化类型，或者说模版类也是一种有效的代码复用技术。在C++的标准模版库中大量应用了这种方式。例如，在定义一个List<String>的变量时，List被另一个类型String所参数化。

设计模式着重于代码的复用，所以在选择复用技术上，有必要看看上述三种复用技术优劣。

继承

+ 通过继承方式，子类能够非常方便地改写父类方法，同时
+ 保留部分父类方法，可以说是能够最快速地达到代码复用。
+ 继承是在静态编译时候就定义了，所以无法再运行时刻改写父类方法。
+ 因为子类没有改写父类方法的话，就相当于依赖了父类这个方法的实现细节,被认为破坏封装性。
+ 并且如果父类接口定义需要更改时，子类也需要提更改响应接口。

组合

+ 对象组合通过获得其他对象引用而在运行时刻动态定义的。
+ 组合要求对象遵守彼此约定，进而要求更仔细地定义接口，而这些接口并不妨碍你将一个对象和另外一个对象一起使用。
+ 对象只能够通过接口来访问，所以我们并没有破坏封装性。
+ 而且只要抽象类型一致，对象是可以被替换的。
+ 使用组合方式，我们可以将类层次限制在比较小的范围内，不容易产生类的爆炸。
+ 相对于继承来说,组合可能需要编写“更多的代码。

参数化类型

+ 参数化类型方式是基于接口的编程，在一定程度上消除了类型给程序设计语言带来的限制。
+ 相对于组合方式来说，缺少的是动态修改能力。
+ 因为参数化类型本身就不是面向对象语言的一个特征，所以在面向对象的设计模式里面，没有一种模式是于参数化类型相关的。
+ 实践上我们方面是可以使用参数化类型来编写某种模式的。

总结

+ 对象组合技术允许你在运行时刻改变被组合的行为，但是它存在间接性，相对来说比较低效。
+ 继承允许你提供操作的缺省实现，通过子类来重定义这些操作，但是不能够在运行时改变。
+ 参数化允许你改变所使用的类型，同样不能够在运行时改变。

## 设计模式

所谓的设计模式是指人们在开发软件的过程中，对于一些普适需求而总结的设计模版。根据模式目的可以分为三类：

+ 创建型(Creational).创建型模式与对象的创建相关。
+ 结构型(Structural).结构型模式处理类或者是对象的组合。
+ 行为型(Behavioral).行为型模式对类或者是对象怎样交互和怎样分配职责进行描述。

下面我们对每种类型进行介绍。具体的模式请见“工具箱”。值得提醒的是，在面试或工作中不可盲目相信设计模式。设计模式更多地只是提供一些思路，能够直接套用设计模式的情况并不多，更多的时候是对现成设计模式的改进和组合。所以对于设计模式的学习更多应该着眼于模式的意图，而不是模式的具体实现方法。

### 创建型

一个类的创建型模式使用继承改变被实例化的类，而一个对象的创建型模式将实例化委托给另外一个对象。 在这些模式中有两种不断出现的主旋律：

+ 将该系统使用哪些具体的类封装起来
+ 隐藏了实例是如何被创建和存储的

总而言之，效果就是用户创建对象的结果是得到一个基类指针，用户通过基类指针调用继承类的方法。用户不需要知道在使用哪些继承类。

#### 单例模式

意图：单例模式(Singleton Pattern)是一种常见的设计模式。其目的在于保证一个类仅仅有一个实例并且提供一个访问它的全局访问点。

这个模式主要的对比对象就是全局变量。相对于全局变量，单例有下面这些好处：

+ 全局变量不能够保证只有一个实例。
+ 某些情况下面，我们需要稍微计算才能够初始化这个单例。全局变量也行但是不自然。
+ C++下面没有保证全局变量的初始化顺序.

比如，在我们之前说的音乐播放器设计中，我们引入了歌曲管理器实现数据的存储。歌曲管理器在整个程序中应当实例化一次，其他所有关于数据的操作都应该在这个实例上进行。所以，歌曲管理器应该应用单例模式。实现单例模式的关键在于利用静态变量(static variable)，通过判断静态变量是否已经初始化判断该类是否已经实例化。此外，还需要把构造函数设为私有函数，通过公共接口getSharedInstance进行调用。我们举例如下：

```
// Example for singleton pattern
// class definition
class MySingleton {
private:
// Private Constructor
    MySingleton();
// Stop the compiler generating methods of copy the object
    MySingleton(const MySingleton &copy);    // Not Implemented
    MySingleton &operator=(const MySingleton &copy);    // Not Implemented
    static MySingleton *m_pInstance;
public:
    static MySingleton *getSharedInstance() {
        if (!m_pInstance) {
            m_pInstance = new MySingleton;
        }
        return m_pInstance;
    }
};

// in the source file
MySingleton *MySingleton::m_pInstance = NULL;
```

注意，本例中的实现方式针对非多线程的情况。如果有过个线程想要同时调用getSharedInstance函数，则需要用mutex保护下列代码：

    pthread_mutex_lock(&mutex);
    if (!m_pInstance) {
        m_pInstance = new MySingleton;
    }
    pthread_mutex_unlock(&mutex);

#### 工厂模式

意图：抽象类需要创建一个对象时，让子类决定实例化哪一个类

所谓的工厂模式(Factory Pattern)，就是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。通常，接口提供传入参数，用以决定实例化什么类。工厂模式常见于工具包和框架中，当需要生成一系列类似的子类时，可以考虑使用工厂模式。举例如下：

```
// class for factory pattern
enum ImageType{
    GIF,
    JPEG
};

class ImageReader {
    // implementation for image reader base class
};

class GIFReader : public ImageReader {
    // implementation for GIF reader derived class
};

class JPEGReader : public ImageReader {
    // implementation for JPEG reader derived class
};

class ImageReaderFactory {
public:
    static ImageReader *imageReaderFactoryMethod(ImageType imageType) {
        ImageReader *product = NULL;
        switch (imageType) {
            case GIF:
                product = new GIFReader();
            case JPEG:
                product = new JPEGReader();
                //...
        }
        return product;
    }
};
```

### 结构型

类的结构型模式采用继承机制来组合接口。对象的结构型模式不是对接口进行组合， 而是描述如何对一些对象进行组合，从而实现新功能。

#### 适配器

意图：适配器(Adapter)将一个类的接口转化成为客户希望的另外一个接口。

假设A实现了Foo()接口，但是B希望A同样实现一个Bar()接口，事实上Foo()基本实现了Bar()接口功能。 Adapter模式就是设计一个新类C，C提供Bar()接口，但实现的方式是内部调用 A的Foo()。

在实现层面上可以通过继承和组合两种方式达到目的：C可以继承A，或者C把A作为自己的成员变量。两者孰优孰劣需要视情况而定。

### 行为型

行为型涉及到算法和对象之间职责的分配。行为模式不仅描述对象或者类的功能行为，还描述它们之间的通信模式。 这些模式刻画了在运行时难以追踪的控制流，它们将你的注意从控制流转移到对象之间的联系上来。

#### 观察者

意图：观察者模式(observer)定义对象之间的依赖关系，当一个对象“状态发生改变的话，所有依赖这个对象的对象都会被通知并且进行更新。

被观察的对象需要能够动态地增删观察者对象，这就要求观察者提供一个公共接口比如Update()。然后每个观察者实例注册到被观察对象里面去，在被观察对象状态更新时候能够遍历所有注册观察者并且调用Update()。

至于观察者和被观察之间是采用push还是pull模式完全取决于应用。对于观察这件事情来说的话， 我们还可以引入方面(Aspect)这样一个概念，在注册观察者的时候不仅仅只是一个观察者对象， 还包括一个Aspect参数，可以以此告诉被观察者仅在发生某些变化时通过调用Update()通知我。

#### 状态

意图：状态模式(state)允许一个对象在其内部状态改变时改变它的行为。

这里状态模式意图是，对于实例A，当A的状态改变时，将A可能改变的行为封装成为一个类S(有多少种可能的状态就有多少个S的子类,比如S1,S2,S3等)。当A的状态转换时，在A内部切换S的实例。从A的用户角度来看，A的接口不变，但A的行为因A的状态改变而改变，这是因为行为的具体实现由S完成。

## 模式